#include <stdio.h>
#include <stdlib.h>
#include "parser.h"
#include "front.h"

static void error();
void printNextToken();

/**
 * BNF Grammar Rules:
 *
 * P ::= S
 * S ::= V:=E | read(V) | write(E) | if C: then S U fi | S;S
 * U ::= else S | e  e = epsilon
 * C ::= (C) | E < E | E > E | E = E | E <> E | E <= E | E >= E
 * E ::= T | E + T | E - T
 * T ::= F | T * F | T / F | T % F
 * F ::= (E) | O | N | V
 * O ::= ++V | --V
 * V ::= a | b | … | y | z | aV | bV | … | yV | zV
 * N ::= 0 | 1 | … | 8 | 9 | 0N | 1N | … | 8N | 9N
 * Where N represent strings in the normal english alphabet
 *
 * program
 * Parses strings in the language generated by the rule:
 * P ::= S
 * S ::= S;S
 **/
void program()
{
    //printf("Enter <program>\n");
    statement();
    //After a statement, if there exists a semicolon as our next token, we
    //expect another statement. Continue until we dont see a semicolon
    while (nextToken == SEMICOLON) {
      lex();
      statement();
    }
    //printf("Exit <program>\n");
}

/* statement
 * Parses strings in the language generated by the rule:
 * S ::= V:=E | read(V) | write(E) | if C: then S U fi
 * */
void statement()
{
    //printf("Enter <statement>\n");
    if (nextToken == IDENT) {
        assignment();
    } else if (nextToken == KEY_READ) {
        readStatement();
    } else if (nextToken == KEY_WRITE) {
        writeStatement();
    } else if (nextToken == KEY_IF) {
        ifStatement();
    } else {
        error();
    }
    //printf("Exit <statement>\n");
}

/* assignment
 * Parses strings in the language generated by the rule:
 * V := E
 */
void assignment()
{
    //printf("Enter <assignment>\n");
    lex(); // Consume IDENT, we expect an := otherwise error
    if (nextToken == ASSIGN_OP) {
        lex();
        if (nextToken == INC_OP || nextToken == DEC_OP) {
          lex();
          if (nextToken == IDENT) {
            lex();
          } else {
            error();
          }
        } else {
          expression();
        }
    } else {
        error();
    }
    //printf("Exit <assignment>\n");
}

/* readStatement
 * Parses strings in the language generated by the rule:
 * read(V)
 */
void readStatement()
{
    //printf("Enter <readStatement>\n");
    lex(); // Consume KEY_READ, we expect a LEFT_PAREN otherwise error
    if (nextToken == LEFT_PAREN) {
        lex(); // Consume LEFT_PAREN, we expect IDENT otherwise error
        if (nextToken == IDENT) {
            lex(); // Consume IDENT, we expect RIGHT_PAREN otherwise error
            if (nextToken == RIGHT_PAREN) {
                lex(); // Consume RIGHT_PAREN, and continue parsing
            } else {
                error();
            }
        } else {
            error();
        }
    } else {
        error();
    }
    //printf("Exit <readStatement>\n");
}

/* writeStatement
 * Parses strings in the language generated by the rule:
 * write(E)
 */
void writeStatement()
{
    //printf("Enter <writeStatement>\n");
    lex(); // Consume KEY_WRITE, we expect a LEFT_PAREN oterwise error
    if (nextToken == LEFT_PAREN) {
        lex(); // Consume LEFT_PAREN, we expect an expression.
        expression(); //Check if expression is valid.
        if (nextToken == RIGHT_PAREN) {
            lex(); // Consume RIGHT_PAREN token
        } else {
            error();
        }
    } else {
        error();
    }
    //printf("Exit <writeStatement>\n");
}

/* ifStatement
 * Parses strings in the language generated by the rule:
 * if C: then S U fi
 */
 void ifStatement()
 {
     //printf("Enter <ifStatement>\n");

     if (nextToken == KEY_IF) { //Must start with if C: then followed by a statement
         lex(); // Consume KEY_IF
         comparison();
         if (nextToken == COLON) {
             lex(); // Consume COLON
             if (nextToken == KEY_THEN) {
                 lex(); // Consume KEY_THEN token
                 program(); // Call program to get statement after then
                 if (nextToken == KEY_ELSE){ // If there exists an
                   lex();
                   program(); // Call program to get statement after else if it exists
                 }
                 if (nextToken == KEY_FI) {
                     lex(); // Consume KEY_FI
                 } else {
                     error();
                 }
             } else {
                 error();
             }
         } else {
             error();
         }
     } else {
         error();
     }

     //printf("Exit <ifStatement>\n");
 }

/* comparison
 * Parses strings in the language generated by the rule:
 * C ::= (C) | E < E | E > E | E = E | E <> E | E <= E | E >= E
 */
void comparison()
{
    //printf("Enter <comparison>\n");
    if (nextToken == LEFT_PAREN) { //if we see a LEFT_PAREN, call comparison again
        lex(); // Consume LEFT_PAREN token
        comparison();
        if (nextToken == RIGHT_PAREN) { //for every LEFT_PAREN there must be a RIGHT_PAREN
            lex(); // Consume RIGHT_PAREN token
        } else {
            error();
        }
    } else {
        expression();
        if (nextToken == LESSER_OP || nextToken == GREATER_OP ||
            nextToken == EQUAL_OP || nextToken == NEQUAL_OP ||
            nextToken == LEQUAL_OP || nextToken == GEQUAL_OP) {
            lex(); // Consume comparison op
            expression();
        } else {
            error();
        }
    }
    //printf("Exit <comparison>\n");
}

/* expression
 * Parses strings in the language generated by the rule:
 * E ::= T | E + T | E - T
 */
void expression()
{
    //printf("Enter <expression>\n");
    term(); //We can see any number of terms here, therefore continue until we dont see one
    while (nextToken == ADD_OP || nextToken == SUB_OP) {
        lex(); // Consume ADD_OP or SUB_OP
        term();
    }
    //printf("Exit <expression>\n");
}

/* term
 * Parses strings in the language generated by the rule:
 * T ::= F | T * F | T / F | T % F
 */
void term()
{
    //printf("Enter <term>\n");
    factor(); //We can see any number of terms here, therefore continue until we dont see one
    while (nextToken == MULT_OP || nextToken == DIV_OP || nextToken == MOD_OP) {
        lex(); // Consume MULT_OP or DIV_OP or MOD_OP
        factor();
    }
    //printf("Exit <term>\n");
}

/* factor
 * Parses strings in the language generated by the rule:
 * F ::= (E) | O | N | V
 */
void factor()
{
    //printf("Enter <factor>\n");
    if (nextToken == LEFT_PAREN) {
        lex();
        expression();
        if (nextToken == RIGHT_PAREN) {
            lex();
        } else {
            error();
        }
    } else if (nextToken == INC_OP || nextToken == DEC_OP) {
        lex(); // Consume the INC or DEC op
        if (nextToken == IDENT) {
            lex(); // Consume IDENT
        } else {
            error();
        }
    } else if (nextToken == IDENT || nextToken == INT_LIT) {
        lex(); // Consume identifier or integer literal
    } else {
        error();
    }
        //printf("Exit <factor>\n");
}

static void error()
{
    printf("Error encountered: The next lexeme was %s and the next token was ", lexeme);
    printNextToken();
    printf("\n");
    exit(1);
}
